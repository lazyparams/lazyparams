/*
 * Copyright 2024 the original author or authors.
 *
 * All rights reserved. This program and the accompanying materials are
 * made available under the terms of the Eclipse Public License v2.0 which
 * accompanies this distribution and is available at
 *
 * https://www.eclipse.org/legal/epl-v20.html
 */
package org.lazyparams.demo.ge17;

import java.io.IOException;
import java.io.Writer;
import java.util.Locale;
import java.util.Set;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.lang.model.SourceVersion;
import javax.tools.FileObject;
import jdk.javadoc.doclet.Doclet;
import jdk.javadoc.doclet.DocletEnvironment;
import jdk.javadoc.doclet.Reporter;
import jdk.javadoc.doclet.StandardDoclet;

import static javax.tools.DocumentationTool.Location.DOCUMENTATION_OUTPUT;

/**
 * This doclet produces pretty normal javadoc but excludes a bunch of nested interfaces of
 * {@link org.lazyparams.showcase.Ensembles} from the package-summary, which otherwise
 * would be bloated with links to technicality interfaces that have been
 * generated by "generate-ensembles-api.pl"! Obviously this is not a test-class but a Doclet
 * implementation that is highly customized for this project.
 * But it is maintained among the test-classes in the specific package "ge17"
 * for convenience. Therewith its maintenance overhead can be kept small
 * by hitchhiking on the project build configuration for the test sources.
 *
 * @author Henrik Kaipe
 */
public class LazyparamsDoclet implements Doclet {

    private final Doclet backend = new StandardDoclet();
    private final Pattern linkToEnsembleInterface = Pattern.compile(
            "<div [^>]++><a ++href=\"Ensembles\\.[A-Z][a-z]++\\.([hA-Z].+?)</div>.*?<div [^>]++>.+?</div>",
            Pattern.DOTALL);

    @Override
    public void init(Locale locale, Reporter reporter) {
        backend.init(locale, reporter);
    }

    @Override
    public String getName() {
        return LazyparamsDoclet.class.getSimpleName();
    }

    @Override
    public Set<? extends Option> getSupportedOptions() {
        return backend.getSupportedOptions();
    }

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return backend.getSupportedSourceVersion();
    }

    @Override
    public boolean run(DocletEnvironment environment) {
        try {
            return backend.run(environment)
                    && postProcess(environment);
        } catch (IOException ex) {
            throw new Error(ex);
        }
    }

    boolean postProcess(DocletEnvironment environment) throws IOException {
        String packageName = "org.lazyparams.showcase";
        FileObject pkgSummary = environment.getJavaFileManager().getFileForOutput(
                DOCUMENTATION_OUTPUT, packageName, "package-summary.html", null);

        CharSequence rawSummaryContent = pkgSummary.getCharContent(true);
        Matcher linkMatch = linkToEnsembleInterface.matcher(rawSummaryContent);
        if (linkMatch.find()) {
            TreeMap<Integer,CharSequence> ensembleInterfacesToKeep = new TreeMap<>();
            try (Writer modifiedSummaryContent = pkgSummary.openWriter()) {
                int lastLinkEnd = 0;
                do {
                    if (lastLinkEnd + 3 < linkMatch.start()) {
                        modifiedSummaryContent.append(
                                rawSummaryContent, lastLinkEnd, linkMatch.start());
                    }
                    lastLinkEnd = linkMatch.end();

                    String keyGroup = linkMatch.group(1);
                    if (keyGroup.startsWith("html")/*==not nested interface within ensemble!*/) {
                        CharSequence withDuplicatedLength = ensembleInterfacesToKeep.put(
                                keyGroup.length(),
                                rawSummaryContent.subSequence(linkMatch.start(), lastLinkEnd));
                        if (null != withDuplicatedLength) {
                            modifiedSummaryContent.append(withDuplicatedLength);
                        }
                    }
                } while (linkMatch.find());

                Pattern backgroundRgx = Pattern.compile("odd|even");
                Matcher backgroundAfterLastLink = backgroundRgx.matcher(rawSummaryContent);
                String withCommonBackground = backgroundAfterLastLink.find(lastLinkEnd)
                        && "odd".equals(backgroundAfterLastLink.group())
                        ? "even" : "odd";
                for (CharSequence eachKeptEnsembleInterface : ensembleInterfacesToKeep.values()) {
                    modifiedSummaryContent.append(backgroundRgx
                            .matcher(eachKeptEnsembleInterface).replaceAll(withCommonBackground));
                }

                modifiedSummaryContent.append(
                        rawSummaryContent, lastLinkEnd, rawSummaryContent.length());
                modifiedSummaryContent.flush();
            }
        } else {
            System.err.println("UNABLE TO FILTER TECHNICAL Ensembles interfaces!");
        }
        return true;
    }
}
